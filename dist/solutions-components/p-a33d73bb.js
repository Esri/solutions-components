/*!
 * Copyright 2022 Esri
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
import{c as n}from"./p-83166522.js";import{h as t}from"./p-c2f00d41.js";
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.0-beta.97
 */const e="hidden-form-input";function o(n){return"checked"in n}const s=new WeakMap,c=new WeakSet;function r(n){const{formEl:t}=n;return!!t&&("requestSubmit"in t?t.requestSubmit():t.submit(),!0)}function i(n){var t;null===(t=n.formEl)||void 0===t||t.reset()}function u(t){const{el:e,value:r}=t,i=n(e,"form");if(!i||function(n,t){const e="calciteInternalFormComponentRegister";let o=!1;return n.addEventListener(e,(n=>{o=n.composedPath().some((n=>c.has(n))),n.stopPropagation()}),{once:!0}),t.dispatchEvent(new CustomEvent(e,{bubbles:!0,composed:!0})),o}(i,e))return;t.formEl=i,t.defaultValue=r,o(t)&&(t.defaultChecked=t.checked);const u=(t.onFormReset||l).bind(t);i.addEventListener("reset",u),s.set(t.el,u),c.add(e)}function l(){o(this)?this.checked=this.defaultChecked:this.value=this.defaultValue}function a(n){const{el:t,formEl:e}=n;if(!e)return;const o=s.get(t);e.removeEventListener("reset",o),s.delete(t),n.formEl=null,c.delete(t)}function f(n,t){n.defaultValue=t}const m=n=>{n.target.dispatchEvent(new CustomEvent("calciteInternalHiddenInputChange",{bubbles:!0}))},d=n=>n.removeEventListener("change",m);function p(n,t,e){var s;const{defaultValue:c,disabled:r,name:i,required:u}=n;t.defaultValue=c,t.disabled=r,t.name=i,t.required=u,t.tabIndex=-1,o(n)?(t.defaultChecked=n.defaultChecked,t.value=n.checked?e||"on":"",r||n.checked||(t.disabled=!0)):t.value=e||"",null===(s=n.syncHiddenFormInput)||void 0===s||s.call(n,t)}const h=({component:n})=>(function(n){const{el:t,formEl:o,name:s,value:c}=n,{ownerDocument:r}=t,i=t.querySelectorAll(`input[slot="${e}"]`);if(!o||!s)return void i.forEach((n=>{d(n),n.remove()}));const u=Array.isArray(c)?c:[c],l=[],a=new Set;let f;i.forEach((t=>{const e=u.find((n=>n==t.value));null!=e?(a.add(e),p(n,t,e)):l.push(t)})),u.forEach((t=>{if(a.has(t))return;let o=l.pop();o||(o=r.createElement("input"),o.slot=e),f||(f=r.createDocumentFragment()),f.append(o),o.addEventListener("change",m),p(n,o,t)})),f&&t.append(f),l.forEach((n=>{d(n),n.remove()}))}(n),t("slot",{name:e}));export{h as H,f as a,u as c,a as d,i as r,r as s}