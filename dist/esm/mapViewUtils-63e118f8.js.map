{"file":"mapViewUtils-63e118f8.js","mappings":"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","names":[],"sources":["./src/utils/queryUtils.ts","./src/utils/mapViewUtils.ts"],"sourcesContent":["/** @license\r\n * Copyright 2022 Esri\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { EWorkflowType, ISelectionSet, IQueryExtentResponse } from \"./interfaces\";\r\n\r\n/**\r\n * Query the layer for all features\r\n *\r\n * @param start zero-based index indicating where to begin retrieving features\r\n * @param layer the layer to retrieve features from\r\n * @param graphics stores the features\r\n *\r\n * @returns Promise with the featureSet from the layer that match the provided ids\r\n */\r\nexport async function queryAllFeatures(\r\n  start: number,\r\n  layer: __esri.FeatureLayer,\r\n  graphics: __esri.Graphic[]\r\n): Promise<__esri.Graphic[]> {\r\n  const num = layer.capabilities.query.maxRecordCount;\r\n  const query = {\r\n    start,\r\n    num,\r\n    outFields: [\"*\"],\r\n    // TODO think through this more...does this make sense\r\n    // may be better to fetch when checkbox is clicked...\r\n    returnGeometry: true,\r\n    where: \"1=1\"\r\n  };\r\n\r\n  const result = await layer.queryFeatures(query);\r\n\r\n  graphics = graphics.concat(\r\n    result.features\r\n  );\r\n\r\n  return result.exceededTransferLimit ?\r\n    queryAllFeatures(start += num, layer, graphics) :\r\n    Promise.resolve(graphics);\r\n}\r\n\r\n/**\r\n * Query the layer for OIDs based on any user drawn geometries or buffers\r\n *\r\n * @param geometries Array of geometries used for the selection of ids from the layer\r\n * @param layer the layer to retrieve ids from\r\n *\r\n * @returns Promise with the OIDs of features from the layer that interset the provided geometries\r\n */\r\nexport async function queryObjectIds(\r\n  geometries: __esri.Geometry[],\r\n  layer: __esri.FeatureLayer\r\n): Promise<number[]> {\r\n  let ids = [];\r\n  const queryDefs = geometries.map(g => _intersectQuery(g, layer))\r\n  const results = await Promise.all(queryDefs);\r\n  results.forEach(resultIds => {\r\n    ids = [\r\n      ...ids,\r\n      ...resultIds || []\r\n    ]\r\n  });\r\n  return ids;\r\n}\r\n\r\n/**\r\n * Query the layer for features that have the provided OIDs\r\n *\r\n * @param ids array of ObjectIDs to be used to query for features in a layer\r\n * @param layer the layer to retrieve features from\r\n *\r\n * @returns Promise with the featureSet from the layer that match the provided ids\r\n */\r\n export async function queryFeaturesByID(\r\n  ids: number[],\r\n  layer: __esri.FeatureLayer\r\n): Promise<__esri.FeatureSet> {\r\n  const q = layer.createQuery();\r\n  q.outFields = [\"*\"];\r\n  q.objectIds = ids;\r\n  return layer.queryFeatures(q);\r\n}\r\n\r\n/**\r\n * Query the layer for features that intersect the provided geometry\r\n *\r\n * @param start zero-based index indicating where to begin retrieving features\r\n * @param layer the layer to retrieve features from\r\n * @param geometry the geometry to apply to the spatial filter\r\n * @param featuresCollection\r\n *\r\n * @returns Promise with the featureSet from the layer that match the provided ids\r\n */\r\nexport async function queryFeaturesByGeometry(\r\n  start: number,\r\n  layer: __esri.FeatureLayer,\r\n  geometry: __esri.Geometry,\r\n  featuresCollection: {[key: string]: __esri.Graphic[]}\r\n): Promise<{[key: string]: __esri.Graphic[]}> {\r\n  const num = layer.capabilities.query.maxRecordCount;\r\n  const query = {\r\n    start,\r\n    num,\r\n    outFields: [\"*\"],\r\n    returnGeometry: true,\r\n    geometry\r\n  };\r\n\r\n  const result = await layer.queryFeatures(query);\r\n  featuresCollection[layer.id] = featuresCollection[layer.id].concat(\r\n    result.features\r\n  );\r\n\r\n  return result.exceededTransferLimit ?\r\n    queryFeaturesByGeometry(start += num, layer, geometry, featuresCollection) :\r\n    Promise.resolve(featuresCollection);\r\n}\r\n\r\n/**\r\n * Query the layer for the extent of features with the provided OIDs\r\n *\r\n * @param ids array of ObjectIDs to be used to query for features in a layer\r\n * @param layer the layer to query\r\n *\r\n * @returns Promise with the Extent of all features that match the provided ids\r\n */\r\n export async function queryExtent(\r\n  ids: number[],\r\n  layer: __esri.FeatureLayer\r\n): Promise<IQueryExtentResponse> {\r\n  const query = layer.createQuery();\r\n  query.objectIds = ids;\r\n  return layer.queryExtent(query);\r\n}\r\n\r\n/**\r\n * Union geometries based on geometry type\r\n *\r\n * @param geometries Array of geometries to union\r\n * @param geometryEngine the geometry engine instance to perform the unions\r\n *\r\n * @returns Array of single unioned geometry for each geometry type\r\n */\r\nexport function getQueryGeoms(\r\n  geometries: __esri.Geometry[],\r\n  geometryEngine: __esri.geometryEngine\r\n): __esri.Geometry[] {\r\n  // sort and union by geom type so we have a single geom for each type to query with\r\n  return [\r\n    ..._unionGeoms(geometries, \"polygon\", geometryEngine),\r\n    ..._unionGeoms(geometries, \"polyline\", geometryEngine),\r\n    ..._unionGeoms(geometries, \"point\", geometryEngine)\r\n  ];\r\n}\r\n\r\n/**\r\n * Get the appropriate ObjectIds query for the provided selection set\r\n *\r\n * @param selectionSet the current selection set to fetch the query for\r\n * @param geometryEngine the geometry engine instance to perform the union of the user drawn graphics or buffers\r\n *\r\n * @returns A promise that will resolve with ids that intersect the selection sets geometries\r\n */\r\nexport function getSelectionSetQuery(\r\n  selectionSet: ISelectionSet,\r\n  geometryEngine: __esri.geometryEngine\r\n): Promise<number[]> {\r\n  let q = Promise.resolve([]);\r\n  if (selectionSet.workflowType !== EWorkflowType.REFINE) {\r\n    if (!selectionSet.buffer) {\r\n      const queryGeoms = getQueryGeoms(\r\n        selectionSet.geometries,\r\n        geometryEngine\r\n      );\r\n      q = queryObjectIds(\r\n        queryGeoms,\r\n        selectionSet.layerView.layer\r\n      );\r\n    } else {\r\n      // buffer is a single unioned geom\r\n      q = queryObjectIds(\r\n        [selectionSet.buffer],\r\n        selectionSet.layerView.layer\r\n      );\r\n    }\r\n  }\r\n  return q;\r\n}\r\n\r\n/**\r\n * Union geometries based on geometry type\r\n *\r\n * @param geometries array of geometries to union\r\n * @param type the current geometry type to union\r\n * @param geometryEngine the geometry engine instance to perform the unions\r\n *\r\n * @returns Array of single unioned geometry for the provided geometry type\r\n */\r\n function _unionGeoms(\r\n  geometries: __esri.Geometry[],\r\n  type: string,\r\n  geometryEngine: __esri.geometryEngine\r\n): __esri.Geometry[] {\r\n  const geoms = geometries.filter(g => g.type === type);\r\n  return geoms.length <= 1 ? geoms : [geometryEngine.union(geoms)];\r\n}\r\n\r\n/**\r\n * Query the layer for ObjectIds of features that intersect the provided geometry\r\n *\r\n * @param geometry Geometry used for the selection of ids from the select layer view\r\n * @param layer the layer to query\r\n *\r\n * @returns Promise that will contain the selected ids\r\n */\r\nasync function _intersectQuery(\r\n  geometry: __esri.Geometry,\r\n  layer: __esri.FeatureLayer\r\n): Promise<number[]> {\r\n  const q = layer.createQuery();\r\n  q.spatialRelationship = \"intersects\";\r\n  q.geometry = geometry;\r\n  return layer.queryObjectIds(q);\r\n}\r\n","/** @license\r\n * Copyright 2022 Esri\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { queryExtent } from \"./queryUtils\";\r\nimport { ILayerHash } from \"./interfaces\";\r\n\r\n/**\r\n * Gets the layer names from the current map\r\n *\r\n * @param mapView the map view to fetch the layer names from\r\n *\r\n * @returns Promise resolving with an array of layer names\r\n *\r\n */\r\nexport async function getMapLayerHash(\r\n  mapView: __esri.MapView\r\n): Promise<ILayerHash> {\r\n  let layerHash = {};\r\n  await mapView.when(() => {\r\n    layerHash = mapView.map.allLayers.toArray().reduce((prev, cur) => {\r\n      if (cur.type === \"feature\") {\r\n        prev[cur.id] = cur.title;\r\n      }\r\n      return prev;\r\n    }, {});\r\n  });\r\n  return layerHash;\r\n}\r\n\r\n/**\r\n * Gets the layer names from the current map\r\n *\r\n * @param mapView the map view to fetch the layer names from\r\n *\r\n * @returns Promise resolving with an array of layer names\r\n *\r\n */\r\nexport async function getMapLayerIds(\r\n  mapView: __esri.MapView\r\n): Promise<string[]> {\r\n  let layerIds = [];\r\n  await mapView.when(() => {\r\n    layerIds = mapView.map.allLayers.toArray().reduce((prev, cur) => {\r\n      if (cur.type === \"feature\") {\r\n        prev.push(cur.id);\r\n      }\r\n      return prev;\r\n    }, []);\r\n  });\r\n  return layerIds;\r\n}\r\n\r\n/**\r\n * Get a layer view by id\r\n *\r\n * @param mapView the map view to fetch the layer from\r\n * @param id the id if the layer to fetch\r\n *\r\n * @returns Promise resolving with the fetched layer view\r\n *\r\n */\r\nexport async function getMapLayerView(\r\n  mapView: __esri.MapView,\r\n  id: string\r\n): Promise<__esri.FeatureLayerView> {\r\n  const layer = await getMapLayer(mapView, id);\r\n  return layer ? await mapView.whenLayerView(layer) : undefined;\r\n}\r\n\r\n/**\r\n * Get a layer by id\r\n *\r\n * @param mapView the map view to fetch the layer from\r\n * @param id the id if the layer to fetch\r\n *\r\n * @returns Promise resolving with the fetched layer\r\n *\r\n */\r\nexport async function getMapLayer(\r\n  mapView: __esri.MapView,\r\n  id: string\r\n): Promise<__esri.FeatureLayer> {\r\n  let layers = [];\r\n  await mapView.when(() => {\r\n    layers = mapView.map.allLayers.toArray().filter((l) => {\r\n      return l.id === id;\r\n    });\r\n  });\r\n  return layers.length > 0 ? layers[0] : undefined;\r\n}\r\n\r\n/**\r\n * Highlight features by OID\r\n *\r\n * @param ids the OIDs from the layer to highlight\r\n * @param layerView the layer view to highlight\r\n * @param mapView the map view used if updateExtent is true\r\n * @param updateExtent optional (default false) boolean to indicate if we should zoom to the extent\r\n *\r\n * @returns Promise resolving with the highlight handle\r\n *\r\n */\r\nexport async function highlightFeatures(\r\n  ids: number[],\r\n  layerView: __esri.FeatureLayerView,\r\n  mapView: __esri.MapView,\r\n  updateExtent = false\r\n): Promise<__esri.Handle> {\r\n  if (updateExtent) {\r\n    await goToSelection(ids, layerView, mapView, false);\r\n  }\r\n  return layerView.highlight(ids);\r\n}\r\n\r\n/**\r\n * Flash features by OID\r\n *\r\n * @param ids the OIDs from the layer to highlight\r\n * @param layerView the layer view to highlight\r\n *\r\n * @returns Promise resolving when the operation is complete\r\n *\r\n */\r\nexport async function flashSelection(\r\n  ids: number[],\r\n  layerView: __esri.FeatureLayerView,\r\n  featureEffect: __esri.FeatureEffect\r\n): Promise<void> {\r\n  const filter = {\r\n    objectIds: ids\r\n  } as __esri.FeatureFilter;\r\n  layerView.featureEffect = {\r\n    ...featureEffect,\r\n    filter\r\n  } as __esri.FeatureEffect;\r\n\r\n  setTimeout(() => {\r\n    layerView.featureEffect = undefined;\r\n  }, 1300);\r\n}\r\n\r\n/**\r\n * Zoom to features based on OID\r\n *\r\n * @param ids the OIDs from the layer to go to\r\n * @param layerView the layer view that contains the OIDs\r\n * @param mapView the map view to show the extent change\r\n * @param flashFeatures optional (default true) boolean to indicate if we should flash the features\r\n *\r\n * @returns Promise resolving when the operation is complete\r\n *\r\n */\r\nexport async function goToSelection(\r\n  ids: number[],\r\n  layerView: __esri.FeatureLayerView,\r\n  mapView: __esri.MapView,\r\n  flashFeatures = true,\r\n  featureEffect: __esri.FeatureEffect = undefined\r\n): Promise<void> {\r\n  const result = await queryExtent(ids, layerView.layer);\r\n  await mapView.goTo(result.extent);\r\n  if (flashFeatures) {\r\n    await flashSelection(ids, layerView, featureEffect);\r\n  }\r\n}\r\n"],"version":3}