{"file":"conditionalSlot-d8471163.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAGA,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;AAC3B,IAAI,gBAAgB,CAAC;AACrB,MAAM,eAAe,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACO,SAAS,+BAA+B,CAAC,SAAS,EAAE;AAC3D,EAAE,IAAI,CAAC,gBAAgB,EAAE;AACzB,IAAI,gBAAgB,GAAGA,wBAAc,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC;AACpE,GAAG;AACH,EAAE,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;AAC1D,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,SAAS,kCAAkC,CAAC,SAAS,EAAE;AAC9D,EAAE,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;AAChC;AACA;AACA;AACA,EAAE,gBAAgB,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAAC;AACnD,EAAE,gBAAgB,CAAC,UAAU,EAAE,CAAC;AAChC,EAAE,KAAK,MAAM,CAAC,OAAO,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;AAC9C,IAAI,gBAAgB,CAAC,OAAO,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;AACvD,GAAG;AACH,CAAC;AACD,SAAS,gBAAgB,CAAC,SAAS,EAAE;AACrC,EAAE,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK;AACpC,IAAIC,iBAAW,CAAC,MAAM,CAAC,CAAC;AACxB,GAAG,CAAC,CAAC;AACL;;;;;","names":["createObserver","forceUpdate"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/conditionalSlot.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { forceUpdate } from \"@stencil/core\";\nimport { createObserver } from \"./observers\";\nconst observed = new Set();\nlet mutationObserver;\nconst observerOptions = { childList: true };\n/**\n * Helper to set up a conditional slot component on connectedCallback.\n *\n * @param component\n */\nexport function connectConditionalSlotComponent(component) {\n  if (!mutationObserver) {\n    mutationObserver = createObserver(\"mutation\", processMutations);\n  }\n  mutationObserver.observe(component.el, observerOptions);\n}\n/**\n * Helper to tear down a conditional slot component on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectConditionalSlotComponent(component) {\n  observed.delete(component.el);\n  // we explicitly process queued mutations and disconnect and reconnect\n  // the observer until MutationObserver gets an `unobserve` method\n  // see https://github.com/whatwg/dom/issues/126\n  processMutations(mutationObserver.takeRecords());\n  mutationObserver.disconnect();\n  for (const [element] of observed.entries()) {\n    mutationObserver.observe(element, observerOptions);\n  }\n}\nfunction processMutations(mutations) {\n  mutations.forEach(({ target }) => {\n    forceUpdate(target);\n  });\n}\n"],"version":3}