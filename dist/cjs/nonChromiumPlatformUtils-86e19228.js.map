{"file":"nonChromiumPlatformUtils-86e19228.js","mappings":"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","names":["rectToClientRect"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/floating-ui/nonChromiumPlatformUtils.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { rectToClientRect } from \"@floating-ui/core\";\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * ðŸ‘‡ the following are needed to fix shadow DOM positioning ðŸ‘‡ï¸\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\nexport { getClippingRect, getElementRects, getOffsetParent };\n/**\n * â˜ï¸ the following are needed to fix shadow DOM positioning â˜ï¸\n */\n/**\n * ðŸ‘‡ the following are taken directly from floating-ui's ESM distributable to support the exports above ðŸ‘‡ï¸\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // â€¢ Always-visible scrollbar or not\n  // â€¢ Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n"],"version":3}